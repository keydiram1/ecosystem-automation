/*
 * Backup Service REST API Specification
 * Aerospike Backup Service
 *
 * The version of the OpenAPI document: v3.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package api.abs.generated.model;

import java.util.Objects;
import api.abs.generated.model.DtoCompressionPolicy;
import api.abs.generated.model.DtoEncryptionPolicy;
import api.abs.generated.model.DtoRetentionPolicy;
import api.abs.generated.model.DtoRetryPolicy;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import api.abs.generated.JSON;

/**
 * BackupPolicy represents a scheduled backup policy.
 */
public class DtoBackupPolicy {
  public static final String SERIALIZED_NAME_BANDWIDTH = "bandwidth";
  @SerializedName(SERIALIZED_NAME_BANDWIDTH)
  @javax.annotation.Nullable
  private Integer bandwidth;

  public static final String SERIALIZED_NAME_COMPRESSION = "compression";
  @SerializedName(SERIALIZED_NAME_COMPRESSION)
  @javax.annotation.Nullable
  private DtoCompressionPolicy compression;

  public static final String SERIALIZED_NAME_CONCURRENT_INCREMENTAL = "concurrent-incremental";
  @SerializedName(SERIALIZED_NAME_CONCURRENT_INCREMENTAL)
  @javax.annotation.Nullable
  private Boolean concurrentIncremental = false;

  public static final String SERIALIZED_NAME_ENCRYPTION = "encryption";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION)
  @javax.annotation.Nullable
  private DtoEncryptionPolicy encryption;

  public static final String SERIALIZED_NAME_FILE_LIMIT = "file-limit";
  @SerializedName(SERIALIZED_NAME_FILE_LIMIT)
  @javax.annotation.Nullable
  private Integer fileLimit = 250;

  public static final String SERIALIZED_NAME_NO_INDEXES = "no-indexes";
  @SerializedName(SERIALIZED_NAME_NO_INDEXES)
  @javax.annotation.Nullable
  private Boolean noIndexes = false;

  public static final String SERIALIZED_NAME_NO_RECORDS = "no-records";
  @SerializedName(SERIALIZED_NAME_NO_RECORDS)
  @javax.annotation.Nullable
  private Boolean noRecords = false;

  public static final String SERIALIZED_NAME_NO_UDFS = "no-udfs";
  @SerializedName(SERIALIZED_NAME_NO_UDFS)
  @javax.annotation.Nullable
  private Boolean noUdfs = false;

  public static final String SERIALIZED_NAME_PARALLEL = "parallel";
  @SerializedName(SERIALIZED_NAME_PARALLEL)
  @javax.annotation.Nullable
  private Integer parallel = 8;

  public static final String SERIALIZED_NAME_PARALLEL_WRITE = "parallel-write";
  @SerializedName(SERIALIZED_NAME_PARALLEL_WRITE)
  @javax.annotation.Nullable
  private Integer parallelWrite = 8;

  public static final String SERIALIZED_NAME_RECORDS_PER_SECOND = "records-per-second";
  @SerializedName(SERIALIZED_NAME_RECORDS_PER_SECOND)
  @javax.annotation.Nullable
  private Integer recordsPerSecond;

  public static final String SERIALIZED_NAME_RETENTION = "retention";
  @SerializedName(SERIALIZED_NAME_RETENTION)
  @javax.annotation.Nullable
  private DtoRetentionPolicy retention;

  public static final String SERIALIZED_NAME_RETRY_POLICY = "retry-policy";
  @SerializedName(SERIALIZED_NAME_RETRY_POLICY)
  @javax.annotation.Nullable
  private DtoRetryPolicy retryPolicy;

  public static final String SERIALIZED_NAME_SEALED = "sealed";
  @SerializedName(SERIALIZED_NAME_SEALED)
  @javax.annotation.Nullable
  private Boolean sealed = false;

  public static final String SERIALIZED_NAME_SOCKET_TIMEOUT = "socket-timeout";
  @SerializedName(SERIALIZED_NAME_SOCKET_TIMEOUT)
  @javax.annotation.Nullable
  private Integer socketTimeout = 60000;

  public static final String SERIALIZED_NAME_TOTAL_TIMEOUT = "total-timeout";
  @SerializedName(SERIALIZED_NAME_TOTAL_TIMEOUT)
  @javax.annotation.Nullable
  private Integer totalTimeout = 0;

  public static final String SERIALIZED_NAME_WITH_CLUSTER_CONFIGURATION = "with-cluster-configuration";
  @SerializedName(SERIALIZED_NAME_WITH_CLUSTER_CONFIGURATION)
  @javax.annotation.Nullable
  private Boolean withClusterConfiguration = false;

  public DtoBackupPolicy() {
  }

  public DtoBackupPolicy bandwidth(@javax.annotation.Nullable Integer bandwidth) {
    this.bandwidth = bandwidth;
    return this;
  }

  /**
   * Throttles backup write speed to a maximum of the specified bandwidth in MiB/s. Default is no limit.
   * @return bandwidth
   */
  @javax.annotation.Nullable
  public Integer getBandwidth() {
    return bandwidth;
  }

  public void setBandwidth(@javax.annotation.Nullable Integer bandwidth) {
    this.bandwidth = bandwidth;
  }


  public DtoBackupPolicy compression(@javax.annotation.Nullable DtoCompressionPolicy compression) {
    this.compression = compression;
    return this;
  }

  /**
   * Compression details (algorithm and mode). Default is no compression. Enabling compression reduces storage and network usage, but increases CPU usage during the backup. Depending on the system configuration, compression may improve or degrade overall performance.
   * @return compression
   */
  @javax.annotation.Nullable
  public DtoCompressionPolicy getCompression() {
    return compression;
  }

  public void setCompression(@javax.annotation.Nullable DtoCompressionPolicy compression) {
    this.compression = compression;
  }


  public DtoBackupPolicy concurrentIncremental(@javax.annotation.Nullable Boolean concurrentIncremental) {
    this.concurrentIncremental = concurrentIncremental;
    return this;
  }

  /**
   * Allows incremental backups to run concurrently. When false (default), incremental backups are skipped if another backup for same routine is in progress.
   * @return concurrentIncremental
   */
  @javax.annotation.Nullable
  public Boolean getConcurrentIncremental() {
    return concurrentIncremental;
  }

  public void setConcurrentIncremental(@javax.annotation.Nullable Boolean concurrentIncremental) {
    this.concurrentIncremental = concurrentIncremental;
  }


  public DtoBackupPolicy encryption(@javax.annotation.Nullable DtoEncryptionPolicy encryption) {
    this.encryption = encryption;
    return this;
  }

  /**
   * Encryption details (algorithm and key). Default is no encryption.
   * @return encryption
   */
  @javax.annotation.Nullable
  public DtoEncryptionPolicy getEncryption() {
    return encryption;
  }

  public void setEncryption(@javax.annotation.Nullable DtoEncryptionPolicy encryption) {
    this.encryption = encryption;
  }


  public DtoBackupPolicy fileLimit(@javax.annotation.Nullable Integer fileLimit) {
    this.fileLimit = fileLimit;
    return this;
  }

  /**
   * File size limit (in MB) for the backup directory. If an .asb backup file crosses this size threshold, a new backup file will be created.
   * @return fileLimit
   */
  @javax.annotation.Nullable
  public Integer getFileLimit() {
    return fileLimit;
  }

  public void setFileLimit(@javax.annotation.Nullable Integer fileLimit) {
    this.fileLimit = fileLimit;
  }


  public DtoBackupPolicy noIndexes(@javax.annotation.Nullable Boolean noIndexes) {
    this.noIndexes = noIndexes;
    return this;
  }

  /**
   * Do not back up any secondary index definitions.
   * @return noIndexes
   */
  @javax.annotation.Nullable
  public Boolean getNoIndexes() {
    return noIndexes;
  }

  public void setNoIndexes(@javax.annotation.Nullable Boolean noIndexes) {
    this.noIndexes = noIndexes;
  }


  public DtoBackupPolicy noRecords(@javax.annotation.Nullable Boolean noRecords) {
    this.noRecords = noRecords;
    return this;
  }

  /**
   * Do not back up any record data (metadata or bin data).
   * @return noRecords
   */
  @javax.annotation.Nullable
  public Boolean getNoRecords() {
    return noRecords;
  }

  public void setNoRecords(@javax.annotation.Nullable Boolean noRecords) {
    this.noRecords = noRecords;
  }


  public DtoBackupPolicy noUdfs(@javax.annotation.Nullable Boolean noUdfs) {
    this.noUdfs = noUdfs;
    return this;
  }

  /**
   * Do not back up any UDF modules.
   * @return noUdfs
   */
  @javax.annotation.Nullable
  public Boolean getNoUdfs() {
    return noUdfs;
  }

  public void setNoUdfs(@javax.annotation.Nullable Boolean noUdfs) {
    this.noUdfs = noUdfs;
  }


  public DtoBackupPolicy parallel(@javax.annotation.Nullable Integer parallel) {
    this.parallel = parallel;
    return this;
  }

  /**
   * Maximum number of scan calls to run in parallel. Each scan call processes a subset of the total data partitions. The optimal value depends on hardware and network configuration.
   * minimum: 1
   * @return parallel
   */
  @javax.annotation.Nullable
  public Integer getParallel() {
    return parallel;
  }

  public void setParallel(@javax.annotation.Nullable Integer parallel) {
    this.parallel = parallel;
  }


  public DtoBackupPolicy parallelWrite(@javax.annotation.Nullable Integer parallelWrite) {
    this.parallelWrite = parallelWrite;
    return this;
  }

  /**
   * Maximum number of threads to use for writing backup files. If not specified, same values as &#x60;parallel&#x60; is used.
   * minimum: 1
   * @return parallelWrite
   */
  @javax.annotation.Nullable
  public Integer getParallelWrite() {
    return parallelWrite;
  }

  public void setParallelWrite(@javax.annotation.Nullable Integer parallelWrite) {
    this.parallelWrite = parallelWrite;
  }


  public DtoBackupPolicy recordsPerSecond(@javax.annotation.Nullable Integer recordsPerSecond) {
    this.recordsPerSecond = recordsPerSecond;
    return this;
  }

  /**
   * Limits the number of records returned per second (RPS). Default is no limit.
   * @return recordsPerSecond
   */
  @javax.annotation.Nullable
  public Integer getRecordsPerSecond() {
    return recordsPerSecond;
  }

  public void setRecordsPerSecond(@javax.annotation.Nullable Integer recordsPerSecond) {
    this.recordsPerSecond = recordsPerSecond;
  }


  public DtoBackupPolicy retention(@javax.annotation.Nullable DtoRetentionPolicy retention) {
    this.retention = retention;
    return this;
  }

  /**
   * Specifies how long to retain full and incremental backups. Cleanup runs asynchronously after each successful full backup, never deleting backups preemptively. Ensure storage capacity for at least one extra full backup beyond the retention configuration.
   * @return retention
   */
  @javax.annotation.Nullable
  public DtoRetentionPolicy getRetention() {
    return retention;
  }

  public void setRetention(@javax.annotation.Nullable DtoRetentionPolicy retention) {
    this.retention = retention;
  }


  public DtoBackupPolicy retryPolicy(@javax.annotation.Nullable DtoRetryPolicy retryPolicy) {
    this.retryPolicy = retryPolicy;
    return this;
  }

  /**
   * RetryPolicy defines the configuration for database scan retry attempts in case of failures. If nil, the default policy is used (5 retries with a one-minute delay between attempts).
   * @return retryPolicy
   */
  @javax.annotation.Nullable
  public DtoRetryPolicy getRetryPolicy() {
    return retryPolicy;
  }

  public void setRetryPolicy(@javax.annotation.Nullable DtoRetryPolicy retryPolicy) {
    this.retryPolicy = retryPolicy;
  }


  public DtoBackupPolicy sealed(@javax.annotation.Nullable Boolean sealed) {
    this.sealed = sealed;
    return this;
  }

  /**
   * Sealed determines whether backup should include keys updated during the backup process. When true, the backup contains only records that last modified before backup started. When false (default), records updated during backup might be included in the backup, but it&#39;s not guaranteed. This parameter does not affect XDR backups (which always includes all keys).
   * @return sealed
   */
  @javax.annotation.Nullable
  public Boolean getSealed() {
    return sealed;
  }

  public void setSealed(@javax.annotation.Nullable Boolean sealed) {
    this.sealed = sealed;
  }


  public DtoBackupPolicy socketTimeout(@javax.annotation.Nullable Integer socketTimeout) {
    this.socketTimeout = socketTimeout;
    return this;
  }

  /**
   * Socket timeout in milliseconds. Default is 10 minutes. If this value is 0, it is set to total-timeout. If both are 0, there is no socket idle time limit.
   * @return socketTimeout
   */
  @javax.annotation.Nullable
  public Integer getSocketTimeout() {
    return socketTimeout;
  }

  public void setSocketTimeout(@javax.annotation.Nullable Integer socketTimeout) {
    this.socketTimeout = socketTimeout;
  }


  public DtoBackupPolicy totalTimeout(@javax.annotation.Nullable Integer totalTimeout) {
    this.totalTimeout = totalTimeout;
    return this;
  }

  /**
   * Total socket timeout in milliseconds. Default is 0, that is, no timeout.
   * @return totalTimeout
   */
  @javax.annotation.Nullable
  public Integer getTotalTimeout() {
    return totalTimeout;
  }

  public void setTotalTimeout(@javax.annotation.Nullable Integer totalTimeout) {
    this.totalTimeout = totalTimeout;
  }


  public DtoBackupPolicy withClusterConfiguration(@javax.annotation.Nullable Boolean withClusterConfiguration) {
    this.withClusterConfiguration = withClusterConfiguration;
    return this;
  }

  /**
   * Back up Aerospike cluster configuration.
   * @return withClusterConfiguration
   */
  @javax.annotation.Nullable
  public Boolean getWithClusterConfiguration() {
    return withClusterConfiguration;
  }

  public void setWithClusterConfiguration(@javax.annotation.Nullable Boolean withClusterConfiguration) {
    this.withClusterConfiguration = withClusterConfiguration;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DtoBackupPolicy dtoBackupPolicy = (DtoBackupPolicy) o;
    return Objects.equals(this.bandwidth, dtoBackupPolicy.bandwidth) &&
        Objects.equals(this.compression, dtoBackupPolicy.compression) &&
        Objects.equals(this.concurrentIncremental, dtoBackupPolicy.concurrentIncremental) &&
        Objects.equals(this.encryption, dtoBackupPolicy.encryption) &&
        Objects.equals(this.fileLimit, dtoBackupPolicy.fileLimit) &&
        Objects.equals(this.noIndexes, dtoBackupPolicy.noIndexes) &&
        Objects.equals(this.noRecords, dtoBackupPolicy.noRecords) &&
        Objects.equals(this.noUdfs, dtoBackupPolicy.noUdfs) &&
        Objects.equals(this.parallel, dtoBackupPolicy.parallel) &&
        Objects.equals(this.parallelWrite, dtoBackupPolicy.parallelWrite) &&
        Objects.equals(this.recordsPerSecond, dtoBackupPolicy.recordsPerSecond) &&
        Objects.equals(this.retention, dtoBackupPolicy.retention) &&
        Objects.equals(this.retryPolicy, dtoBackupPolicy.retryPolicy) &&
        Objects.equals(this.sealed, dtoBackupPolicy.sealed) &&
        Objects.equals(this.socketTimeout, dtoBackupPolicy.socketTimeout) &&
        Objects.equals(this.totalTimeout, dtoBackupPolicy.totalTimeout) &&
        Objects.equals(this.withClusterConfiguration, dtoBackupPolicy.withClusterConfiguration);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(bandwidth, compression, concurrentIncremental, encryption, fileLimit, noIndexes, noRecords, noUdfs, parallel, parallelWrite, recordsPerSecond, retention, retryPolicy, sealed, socketTimeout, totalTimeout, withClusterConfiguration);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DtoBackupPolicy {\n");
    sb.append("    bandwidth: ").append(toIndentedString(bandwidth)).append("\n");
    sb.append("    compression: ").append(toIndentedString(compression)).append("\n");
    sb.append("    concurrentIncremental: ").append(toIndentedString(concurrentIncremental)).append("\n");
    sb.append("    encryption: ").append(toIndentedString(encryption)).append("\n");
    sb.append("    fileLimit: ").append(toIndentedString(fileLimit)).append("\n");
    sb.append("    noIndexes: ").append(toIndentedString(noIndexes)).append("\n");
    sb.append("    noRecords: ").append(toIndentedString(noRecords)).append("\n");
    sb.append("    noUdfs: ").append(toIndentedString(noUdfs)).append("\n");
    sb.append("    parallel: ").append(toIndentedString(parallel)).append("\n");
    sb.append("    parallelWrite: ").append(toIndentedString(parallelWrite)).append("\n");
    sb.append("    recordsPerSecond: ").append(toIndentedString(recordsPerSecond)).append("\n");
    sb.append("    retention: ").append(toIndentedString(retention)).append("\n");
    sb.append("    retryPolicy: ").append(toIndentedString(retryPolicy)).append("\n");
    sb.append("    sealed: ").append(toIndentedString(sealed)).append("\n");
    sb.append("    socketTimeout: ").append(toIndentedString(socketTimeout)).append("\n");
    sb.append("    totalTimeout: ").append(toIndentedString(totalTimeout)).append("\n");
    sb.append("    withClusterConfiguration: ").append(toIndentedString(withClusterConfiguration)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("bandwidth", "compression", "concurrent-incremental", "encryption", "file-limit", "no-indexes", "no-records", "no-udfs", "parallel", "parallel-write", "records-per-second", "retention", "retry-policy", "sealed", "socket-timeout", "total-timeout", "with-cluster-configuration"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(0);
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DtoBackupPolicy
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DtoBackupPolicy.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DtoBackupPolicy is not found in the empty JSON string", DtoBackupPolicy.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DtoBackupPolicy.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DtoBackupPolicy` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `compression`
      if (jsonObj.get("compression") != null && !jsonObj.get("compression").isJsonNull()) {
        DtoCompressionPolicy.validateJsonElement(jsonObj.get("compression"));
      }
      // validate the optional field `encryption`
      if (jsonObj.get("encryption") != null && !jsonObj.get("encryption").isJsonNull()) {
        DtoEncryptionPolicy.validateJsonElement(jsonObj.get("encryption"));
      }
      // validate the optional field `retention`
      if (jsonObj.get("retention") != null && !jsonObj.get("retention").isJsonNull()) {
        DtoRetentionPolicy.validateJsonElement(jsonObj.get("retention"));
      }
      // validate the optional field `retry-policy`
      if (jsonObj.get("retry-policy") != null && !jsonObj.get("retry-policy").isJsonNull()) {
        DtoRetryPolicy.validateJsonElement(jsonObj.get("retry-policy"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DtoBackupPolicy.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DtoBackupPolicy' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DtoBackupPolicy> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DtoBackupPolicy.class));

       return (TypeAdapter<T>) new TypeAdapter<DtoBackupPolicy>() {
           @Override
           public void write(JsonWriter out, DtoBackupPolicy value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DtoBackupPolicy read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DtoBackupPolicy given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DtoBackupPolicy
   * @throws IOException if the JSON string is invalid with respect to DtoBackupPolicy
   */
  public static DtoBackupPolicy fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DtoBackupPolicy.class);
  }

  /**
   * Convert an instance of DtoBackupPolicy to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

