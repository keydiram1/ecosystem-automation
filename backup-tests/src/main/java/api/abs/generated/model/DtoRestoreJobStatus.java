/*
 * Backup Service REST API Specification
 * Aerospike Backup Service
 *
 * The version of the OpenAPI document: v3.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package api.abs.generated.model;

import java.util.Objects;
import api.abs.generated.model.DtoJobStatus;
import api.abs.generated.model.DtoRunningJob;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import api.abs.generated.JSON;

/**
 * RestoreJobStatus represents restore job status.
 */
public class DtoRestoreJobStatus {
  public static final String SERIALIZED_NAME_CURRENT_JOB = "current-job";
  @SerializedName(SERIALIZED_NAME_CURRENT_JOB)
  @javax.annotation.Nullable
  private DtoRunningJob currentJob;

  public static final String SERIALIZED_NAME_ERROR = "error";
  @SerializedName(SERIALIZED_NAME_ERROR)
  @javax.annotation.Nullable
  private String error;

  public static final String SERIALIZED_NAME_ERRORS_IN_DOUBT = "errors-in-doubt";
  @SerializedName(SERIALIZED_NAME_ERRORS_IN_DOUBT)
  @javax.annotation.Nullable
  private Long errorsInDoubt;

  public static final String SERIALIZED_NAME_EXISTED_RECORDS = "existed-records";
  @SerializedName(SERIALIZED_NAME_EXISTED_RECORDS)
  @javax.annotation.Nullable
  private Long existedRecords;

  public static final String SERIALIZED_NAME_EXPIRED_RECORDS = "expired-records";
  @SerializedName(SERIALIZED_NAME_EXPIRED_RECORDS)
  @javax.annotation.Nullable
  private Long expiredRecords;

  public static final String SERIALIZED_NAME_FRESHER_RECORDS = "fresher-records";
  @SerializedName(SERIALIZED_NAME_FRESHER_RECORDS)
  @javax.annotation.Nullable
  private Long fresherRecords;

  public static final String SERIALIZED_NAME_IGNORED_RECORDS = "ignored-records";
  @SerializedName(SERIALIZED_NAME_IGNORED_RECORDS)
  @javax.annotation.Nullable
  private Long ignoredRecords;

  public static final String SERIALIZED_NAME_INDEX_COUNT = "index-count";
  @SerializedName(SERIALIZED_NAME_INDEX_COUNT)
  @javax.annotation.Nullable
  private Long indexCount;

  public static final String SERIALIZED_NAME_INSERTED_RECORDS = "inserted-records";
  @SerializedName(SERIALIZED_NAME_INSERTED_RECORDS)
  @javax.annotation.Nullable
  private Long insertedRecords;

  public static final String SERIALIZED_NAME_READ_RECORDS = "read-records";
  @SerializedName(SERIALIZED_NAME_READ_RECORDS)
  @javax.annotation.Nullable
  private Long readRecords;

  public static final String SERIALIZED_NAME_SKIPPED_RECORDS = "skipped-records";
  @SerializedName(SERIALIZED_NAME_SKIPPED_RECORDS)
  @javax.annotation.Nullable
  private Long skippedRecords;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  @javax.annotation.Nullable
  private DtoJobStatus status;

  public static final String SERIALIZED_NAME_TOTAL_BYTES = "total-bytes";
  @SerializedName(SERIALIZED_NAME_TOTAL_BYTES)
  @javax.annotation.Nullable
  private Long totalBytes;

  public static final String SERIALIZED_NAME_UDF_COUNT = "udf-count";
  @SerializedName(SERIALIZED_NAME_UDF_COUNT)
  @javax.annotation.Nullable
  private Long udfCount;

  public DtoRestoreJobStatus() {
  }

  public DtoRestoreJobStatus currentJob(@javax.annotation.Nullable DtoRunningJob currentJob) {
    this.currentJob = currentJob;
    return this;
  }

  /**
   * Speed related metrics of the restore process.
   * @return currentJob
   */
  @javax.annotation.Nullable
  public DtoRunningJob getCurrentJob() {
    return currentJob;
  }

  public void setCurrentJob(@javax.annotation.Nullable DtoRunningJob currentJob) {
    this.currentJob = currentJob;
  }


  public DtoRestoreJobStatus error(@javax.annotation.Nullable String error) {
    this.error = error;
    return this;
  }

  /**
   * Error message if any.
   * @return error
   */
  @javax.annotation.Nullable
  public String getError() {
    return error;
  }

  public void setError(@javax.annotation.Nullable String error) {
    this.error = error;
  }


  public DtoRestoreJobStatus errorsInDoubt(@javax.annotation.Nullable Long errorsInDoubt) {
    this.errorsInDoubt = errorsInDoubt;
    return this;
  }

  /**
   * The number of errors in doubt while restoring. (IsInDoubt signifies that the write operation may have gone through on the server but the client is not able to confirm that due an error.) Non zero value indicates that there are might be unexpected side effects during restore, like * Generation counter greater than expected for some records. * Fresher records counter greater than expected.
   * @return errorsInDoubt
   */
  @javax.annotation.Nullable
  public Long getErrorsInDoubt() {
    return errorsInDoubt;
  }

  public void setErrorsInDoubt(@javax.annotation.Nullable Long errorsInDoubt) {
    this.errorsInDoubt = errorsInDoubt;
  }


  public DtoRestoreJobStatus existedRecords(@javax.annotation.Nullable Long existedRecords) {
    this.existedRecords = existedRecords;
    return this;
  }

  /**
   * The number of records dropped because they already existed in the database.
   * @return existedRecords
   */
  @javax.annotation.Nullable
  public Long getExistedRecords() {
    return existedRecords;
  }

  public void setExistedRecords(@javax.annotation.Nullable Long existedRecords) {
    this.existedRecords = existedRecords;
  }


  public DtoRestoreJobStatus expiredRecords(@javax.annotation.Nullable Long expiredRecords) {
    this.expiredRecords = expiredRecords;
    return this;
  }

  /**
   * The number of records dropped because they were expired.
   * @return expiredRecords
   */
  @javax.annotation.Nullable
  public Long getExpiredRecords() {
    return expiredRecords;
  }

  public void setExpiredRecords(@javax.annotation.Nullable Long expiredRecords) {
    this.expiredRecords = expiredRecords;
  }


  public DtoRestoreJobStatus fresherRecords(@javax.annotation.Nullable Long fresherRecords) {
    this.fresherRecords = fresherRecords;
    return this;
  }

  /**
   * The number of records dropped because the database already contained the records with a higher generation count.
   * @return fresherRecords
   */
  @javax.annotation.Nullable
  public Long getFresherRecords() {
    return fresherRecords;
  }

  public void setFresherRecords(@javax.annotation.Nullable Long fresherRecords) {
    this.fresherRecords = fresherRecords;
  }


  public DtoRestoreJobStatus ignoredRecords(@javax.annotation.Nullable Long ignoredRecords) {
    this.ignoredRecords = ignoredRecords;
    return this;
  }

  /**
   * The number of records ignored because of a record-level permanent error while restoring.
   * @return ignoredRecords
   */
  @javax.annotation.Nullable
  public Long getIgnoredRecords() {
    return ignoredRecords;
  }

  public void setIgnoredRecords(@javax.annotation.Nullable Long ignoredRecords) {
    this.ignoredRecords = ignoredRecords;
  }


  public DtoRestoreJobStatus indexCount(@javax.annotation.Nullable Long indexCount) {
    this.indexCount = indexCount;
    return this;
  }

  /**
   * The number of successfully created secondary indexes.
   * @return indexCount
   */
  @javax.annotation.Nullable
  public Long getIndexCount() {
    return indexCount;
  }

  public void setIndexCount(@javax.annotation.Nullable Long indexCount) {
    this.indexCount = indexCount;
  }


  public DtoRestoreJobStatus insertedRecords(@javax.annotation.Nullable Long insertedRecords) {
    this.insertedRecords = insertedRecords;
    return this;
  }

  /**
   * The number of successfully restored records.
   * @return insertedRecords
   */
  @javax.annotation.Nullable
  public Long getInsertedRecords() {
    return insertedRecords;
  }

  public void setInsertedRecords(@javax.annotation.Nullable Long insertedRecords) {
    this.insertedRecords = insertedRecords;
  }


  public DtoRestoreJobStatus readRecords(@javax.annotation.Nullable Long readRecords) {
    this.readRecords = readRecords;
    return this;
  }

  /**
   * Number of records read from backup. When restore is finished, &#x60;read-records&#x60; &#x3D;  &#x60;inserted-records&#x60; + &#x60;fresher-records&#x60; + &#x60;existed-records&#x60; + &#x60;ignored-records&#x60; + &#x60;skipped-records&#x60; + &#x60;expired-records&#x60;
   * @return readRecords
   */
  @javax.annotation.Nullable
  public Long getReadRecords() {
    return readRecords;
  }

  public void setReadRecords(@javax.annotation.Nullable Long readRecords) {
    this.readRecords = readRecords;
  }


  public DtoRestoreJobStatus skippedRecords(@javax.annotation.Nullable Long skippedRecords) {
    this.skippedRecords = skippedRecords;
    return this;
  }

  /**
   * The number of records dropped because they didn&#39;t contain any of the selected bins or didn&#39;t belong to any of the selected sets.
   * @return skippedRecords
   */
  @javax.annotation.Nullable
  public Long getSkippedRecords() {
    return skippedRecords;
  }

  public void setSkippedRecords(@javax.annotation.Nullable Long skippedRecords) {
    this.skippedRecords = skippedRecords;
  }


  public DtoRestoreJobStatus status(@javax.annotation.Nullable DtoJobStatus status) {
    this.status = status;
    return this;
  }

  /**
   * Status of the restore job.
   * @return status
   */
  @javax.annotation.Nullable
  public DtoJobStatus getStatus() {
    return status;
  }

  public void setStatus(@javax.annotation.Nullable DtoJobStatus status) {
    this.status = status;
  }


  public DtoRestoreJobStatus totalBytes(@javax.annotation.Nullable Long totalBytes) {
    this.totalBytes = totalBytes;
    return this;
  }

  /**
   * Total bytes read from backup.
   * @return totalBytes
   */
  @javax.annotation.Nullable
  public Long getTotalBytes() {
    return totalBytes;
  }

  public void setTotalBytes(@javax.annotation.Nullable Long totalBytes) {
    this.totalBytes = totalBytes;
  }


  public DtoRestoreJobStatus udfCount(@javax.annotation.Nullable Long udfCount) {
    this.udfCount = udfCount;
    return this;
  }

  /**
   * The number of successfully stored UDF files.
   * @return udfCount
   */
  @javax.annotation.Nullable
  public Long getUdfCount() {
    return udfCount;
  }

  public void setUdfCount(@javax.annotation.Nullable Long udfCount) {
    this.udfCount = udfCount;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DtoRestoreJobStatus dtoRestoreJobStatus = (DtoRestoreJobStatus) o;
    return Objects.equals(this.currentJob, dtoRestoreJobStatus.currentJob) &&
        Objects.equals(this.error, dtoRestoreJobStatus.error) &&
        Objects.equals(this.errorsInDoubt, dtoRestoreJobStatus.errorsInDoubt) &&
        Objects.equals(this.existedRecords, dtoRestoreJobStatus.existedRecords) &&
        Objects.equals(this.expiredRecords, dtoRestoreJobStatus.expiredRecords) &&
        Objects.equals(this.fresherRecords, dtoRestoreJobStatus.fresherRecords) &&
        Objects.equals(this.ignoredRecords, dtoRestoreJobStatus.ignoredRecords) &&
        Objects.equals(this.indexCount, dtoRestoreJobStatus.indexCount) &&
        Objects.equals(this.insertedRecords, dtoRestoreJobStatus.insertedRecords) &&
        Objects.equals(this.readRecords, dtoRestoreJobStatus.readRecords) &&
        Objects.equals(this.skippedRecords, dtoRestoreJobStatus.skippedRecords) &&
        Objects.equals(this.status, dtoRestoreJobStatus.status) &&
        Objects.equals(this.totalBytes, dtoRestoreJobStatus.totalBytes) &&
        Objects.equals(this.udfCount, dtoRestoreJobStatus.udfCount);
  }

  @Override
  public int hashCode() {
    return Objects.hash(currentJob, error, errorsInDoubt, existedRecords, expiredRecords, fresherRecords, ignoredRecords, indexCount, insertedRecords, readRecords, skippedRecords, status, totalBytes, udfCount);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DtoRestoreJobStatus {\n");
    sb.append("    currentJob: ").append(toIndentedString(currentJob)).append("\n");
    sb.append("    error: ").append(toIndentedString(error)).append("\n");
    sb.append("    errorsInDoubt: ").append(toIndentedString(errorsInDoubt)).append("\n");
    sb.append("    existedRecords: ").append(toIndentedString(existedRecords)).append("\n");
    sb.append("    expiredRecords: ").append(toIndentedString(expiredRecords)).append("\n");
    sb.append("    fresherRecords: ").append(toIndentedString(fresherRecords)).append("\n");
    sb.append("    ignoredRecords: ").append(toIndentedString(ignoredRecords)).append("\n");
    sb.append("    indexCount: ").append(toIndentedString(indexCount)).append("\n");
    sb.append("    insertedRecords: ").append(toIndentedString(insertedRecords)).append("\n");
    sb.append("    readRecords: ").append(toIndentedString(readRecords)).append("\n");
    sb.append("    skippedRecords: ").append(toIndentedString(skippedRecords)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    totalBytes: ").append(toIndentedString(totalBytes)).append("\n");
    sb.append("    udfCount: ").append(toIndentedString(udfCount)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("current-job", "error", "errors-in-doubt", "existed-records", "expired-records", "fresher-records", "ignored-records", "index-count", "inserted-records", "read-records", "skipped-records", "status", "total-bytes", "udf-count"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(0);
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DtoRestoreJobStatus
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DtoRestoreJobStatus.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DtoRestoreJobStatus is not found in the empty JSON string", DtoRestoreJobStatus.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DtoRestoreJobStatus.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DtoRestoreJobStatus` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `current-job`
      if (jsonObj.get("current-job") != null && !jsonObj.get("current-job").isJsonNull()) {
        DtoRunningJob.validateJsonElement(jsonObj.get("current-job"));
      }
      if ((jsonObj.get("error") != null && !jsonObj.get("error").isJsonNull()) && !jsonObj.get("error").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `error` to be a primitive type in the JSON string but got `%s`", jsonObj.get("error").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        DtoJobStatus.validateJsonElement(jsonObj.get("status"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DtoRestoreJobStatus.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DtoRestoreJobStatus' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DtoRestoreJobStatus> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DtoRestoreJobStatus.class));

       return (TypeAdapter<T>) new TypeAdapter<DtoRestoreJobStatus>() {
           @Override
           public void write(JsonWriter out, DtoRestoreJobStatus value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DtoRestoreJobStatus read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DtoRestoreJobStatus given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DtoRestoreJobStatus
   * @throws IOException if the JSON string is invalid with respect to DtoRestoreJobStatus
   */
  public static DtoRestoreJobStatus fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DtoRestoreJobStatus.class);
  }

  /**
   * Convert an instance of DtoRestoreJobStatus to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

