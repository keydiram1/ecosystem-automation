/*
 * Backup Service REST API Specification
 * Aerospike Backup Service
 *
 * The version of the OpenAPI document: v3.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package api.abs.generated.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import api.abs.generated.JSON;

/**
 * BackupRoutine represents a scheduled backup operation routine.
 */
public class DtoBackupRoutine {
  public static final String SERIALIZED_NAME_BACKUP_POLICY = "backup-policy";
  @SerializedName(SERIALIZED_NAME_BACKUP_POLICY)
  @javax.annotation.Nullable
  private String backupPolicy;

  public static final String SERIALIZED_NAME_BIN_LIST = "bin-list";
  @SerializedName(SERIALIZED_NAME_BIN_LIST)
  @javax.annotation.Nullable
  private List<String> binList;

  public static final String SERIALIZED_NAME_DISABLED = "disabled";
  @SerializedName(SERIALIZED_NAME_DISABLED)
  @javax.annotation.Nullable
  private Boolean disabled = false;

  public static final String SERIALIZED_NAME_INCR_INTERVAL_CRON = "incr-interval-cron";
  @SerializedName(SERIALIZED_NAME_INCR_INTERVAL_CRON)
  @javax.annotation.Nullable
  private String incrIntervalCron;

  public static final String SERIALIZED_NAME_INTERVAL_CRON = "interval-cron";
  @SerializedName(SERIALIZED_NAME_INTERVAL_CRON)
  @javax.annotation.Nonnull
  private String intervalCron;

  public static final String SERIALIZED_NAME_NAMESPACES = "namespaces";
  @SerializedName(SERIALIZED_NAME_NAMESPACES)
  @javax.annotation.Nonnull
  private List<String> namespaces = new ArrayList<>();

  public static final String SERIALIZED_NAME_NODE_LIST = "node-list";
  @SerializedName(SERIALIZED_NAME_NODE_LIST)
  @javax.annotation.Nullable
  private List<String> nodeList;

  public static final String SERIALIZED_NAME_PARTITION_LIST = "partition-list";
  @SerializedName(SERIALIZED_NAME_PARTITION_LIST)
  @javax.annotation.Nullable
  private String partitionList;

  public static final String SERIALIZED_NAME_PREFER_RACKS = "prefer-racks";
  @SerializedName(SERIALIZED_NAME_PREFER_RACKS)
  @javax.annotation.Nullable
  private List<Integer> preferRacks;

  public static final String SERIALIZED_NAME_SECRET_AGENT = "secret-agent";
  @SerializedName(SERIALIZED_NAME_SECRET_AGENT)
  @javax.annotation.Nullable
  private String secretAgent;

  public static final String SERIALIZED_NAME_SET_LIST = "set-list";
  @SerializedName(SERIALIZED_NAME_SET_LIST)
  @javax.annotation.Nullable
  private List<String> setList;

  public static final String SERIALIZED_NAME_SOURCE_CLUSTER = "source-cluster";
  @SerializedName(SERIALIZED_NAME_SOURCE_CLUSTER)
  @javax.annotation.Nonnull
  private String sourceCluster;

  public static final String SERIALIZED_NAME_STORAGE = "storage";
  @SerializedName(SERIALIZED_NAME_STORAGE)
  @javax.annotation.Nonnull
  private String storage;

  public DtoBackupRoutine() {
  }

  public DtoBackupRoutine backupPolicy(@javax.annotation.Nullable String backupPolicy) {
    this.backupPolicy = backupPolicy;
    return this;
  }

  /**
   * The name of the corresponding backup policy, one of defined in &#x60;config.backup-policies&#x60; (optional).
   * @return backupPolicy
   */
  @javax.annotation.Nullable
  public String getBackupPolicy() {
    return backupPolicy;
  }

  public void setBackupPolicy(@javax.annotation.Nullable String backupPolicy) {
    this.backupPolicy = backupPolicy;
  }


  public DtoBackupRoutine binList(@javax.annotation.Nullable List<String> binList) {
    this.binList = binList;
    return this;
  }

  public DtoBackupRoutine addBinListItem(String binListItem) {
    if (this.binList == null) {
      this.binList = new ArrayList<>();
    }
    this.binList.add(binListItem);
    return this;
  }

  /**
   * The list of backup bin names (optional, an empty list implies backing up all bins) extensions:\&quot;x-nullable\&quot;.
   * @return binList
   */
  @javax.annotation.Nullable
  public List<String> getBinList() {
    return binList;
  }

  public void setBinList(@javax.annotation.Nullable List<String> binList) {
    this.binList = binList;
  }


  public DtoBackupRoutine disabled(@javax.annotation.Nullable Boolean disabled) {
    this.disabled = disabled;
    return this;
  }

  /**
   * Whether this routine is disabled and should not run. Default: false.
   * @return disabled
   */
  @javax.annotation.Nullable
  public Boolean getDisabled() {
    return disabled;
  }

  public void setDisabled(@javax.annotation.Nullable Boolean disabled) {
    this.disabled = disabled;
  }


  public DtoBackupRoutine incrIntervalCron(@javax.annotation.Nullable String incrIntervalCron) {
    this.incrIntervalCron = incrIntervalCron;
    return this;
  }

  /**
   * The interval for incremental backup as a cron expression string (optional).
   * @return incrIntervalCron
   */
  @javax.annotation.Nullable
  public String getIncrIntervalCron() {
    return incrIntervalCron;
  }

  public void setIncrIntervalCron(@javax.annotation.Nullable String incrIntervalCron) {
    this.incrIntervalCron = incrIntervalCron;
  }


  public DtoBackupRoutine intervalCron(@javax.annotation.Nonnull String intervalCron) {
    this.intervalCron = intervalCron;
    return this;
  }

  /**
   * The interval for full backup as a cron expression string. Cron expression format: https://github.com/reugn/go-quartz?tab&#x3D;readme-ov-file#cron-expression-format
   * @return intervalCron
   */
  @javax.annotation.Nonnull
  public String getIntervalCron() {
    return intervalCron;
  }

  public void setIntervalCron(@javax.annotation.Nonnull String intervalCron) {
    this.intervalCron = intervalCron;
  }


  public DtoBackupRoutine namespaces(@javax.annotation.Nonnull List<String> namespaces) {
    this.namespaces = namespaces;
    return this;
  }

  public DtoBackupRoutine addNamespacesItem(String namespacesItem) {
    if (this.namespaces == null) {
      this.namespaces = new ArrayList<>();
    }
    this.namespaces.add(namespacesItem);
    return this;
  }

  /**
   * The list of the namespaces to back up (empty list implies backup of the whole cluster).
   * @return namespaces
   */
  @javax.annotation.Nonnull
  public List<String> getNamespaces() {
    return namespaces;
  }

  public void setNamespaces(@javax.annotation.Nonnull List<String> namespaces) {
    this.namespaces = namespaces;
  }


  public DtoBackupRoutine nodeList(@javax.annotation.Nullable List<String> nodeList) {
    this.nodeList = nodeList;
    return this;
  }

  public DtoBackupRoutine addNodeListItem(String nodeListItem) {
    if (this.nodeList == null) {
      this.nodeList = new ArrayList<>();
    }
    this.nodeList.add(nodeListItem);
    return this;
  }

  /**
   * NodeList specifies which Aerospike nodes to include in the backup. Only the listed nodes will be backed up. Each node can be specified as one of the following: - \&quot;&lt;IP address&gt;:&lt;port&gt;\&quot; - \&quot;&lt;hostname&gt;:&lt;port&gt;\&quot; - \&quot;&lt;node ID&gt;\&quot; To obtain node identifiers, run: &#x60;asinfo -v \&quot;service:\&quot;&#x60;. If using IP addresses or hostnames, ensure they match the values returned by the &#x60;asinfo&#x60; command. This field is mutually exclusive with partition-list. Parallelism is determined by the number of listed nodes unless &#x60;BackupPolicy.Parallel&#x60; is set to a lower value.
   * @return nodeList
   */
  @javax.annotation.Nullable
  public List<String> getNodeList() {
    return nodeList;
  }

  public void setNodeList(@javax.annotation.Nullable List<String> nodeList) {
    this.nodeList = nodeList;
  }


  public DtoBackupRoutine partitionList(@javax.annotation.Nullable String partitionList) {
    this.partitionList = partitionList;
    return this;
  }

  /**
   * PartitionList defines the list of partitions to include in the backup. The format supports individual partitions or ranges. - A range is specified as \&quot;&lt;start&gt;-&lt;count&gt;\&quot; (e.g., \&quot;100-50\&quot; backs up 50 partitions starting from 100). - A single partition is specified as a number (e.g., \&quot;0\&quot;). Multiple entries can be comma-separated: e.g., \&quot;0,100,200,300,400,500\&quot;. By default, all partitions (0 to 4095) are backed up. This field is mutually exclusive with node-list.
   * @return partitionList
   */
  @javax.annotation.Nullable
  public String getPartitionList() {
    return partitionList;
  }

  public void setPartitionList(@javax.annotation.Nullable String partitionList) {
    this.partitionList = partitionList;
  }


  public DtoBackupRoutine preferRacks(@javax.annotation.Nullable List<Integer> preferRacks) {
    this.preferRacks = preferRacks;
    return this;
  }

  public DtoBackupRoutine addPreferRacksItem(Integer preferRacksItem) {
    if (this.preferRacks == null) {
      this.preferRacks = new ArrayList<>();
    }
    this.preferRacks.add(preferRacksItem);
    return this;
  }

  /**
   * The list of Aerospike Server rack IDs to prioritize when reading records during backup. This is optional and can be used to optimize for rack-aware deployments.
   * @return preferRacks
   */
  @javax.annotation.Nullable
  public List<Integer> getPreferRacks() {
    return preferRacks;
  }

  public void setPreferRacks(@javax.annotation.Nullable List<Integer> preferRacks) {
    this.preferRacks = preferRacks;
  }


  public DtoBackupRoutine secretAgent(@javax.annotation.Nullable String secretAgent) {
    this.secretAgent = secretAgent;
    return this;
  }

  /**
   * The name of a Secret Agent to read secrets from (optional).
   * @return secretAgent
   */
  @javax.annotation.Nullable
  public String getSecretAgent() {
    return secretAgent;
  }

  public void setSecretAgent(@javax.annotation.Nullable String secretAgent) {
    this.secretAgent = secretAgent;
  }


  public DtoBackupRoutine setList(@javax.annotation.Nullable List<String> setList) {
    this.setList = setList;
    return this;
  }

  public DtoBackupRoutine addSetListItem(String setListItem) {
    if (this.setList == null) {
      this.setList = new ArrayList<>();
    }
    this.setList.add(setListItem);
    return this;
  }

  /**
   * The list of backup set names (optional, an empty list implies backing up all sets).
   * @return setList
   */
  @javax.annotation.Nullable
  public List<String> getSetList() {
    return setList;
  }

  public void setSetList(@javax.annotation.Nullable List<String> setList) {
    this.setList = setList;
  }


  public DtoBackupRoutine sourceCluster(@javax.annotation.Nonnull String sourceCluster) {
    this.sourceCluster = sourceCluster;
    return this;
  }

  /**
   * The name of the corresponding source cluster.
   * @return sourceCluster
   */
  @javax.annotation.Nonnull
  public String getSourceCluster() {
    return sourceCluster;
  }

  public void setSourceCluster(@javax.annotation.Nonnull String sourceCluster) {
    this.sourceCluster = sourceCluster;
  }


  public DtoBackupRoutine storage(@javax.annotation.Nonnull String storage) {
    this.storage = storage;
    return this;
  }

  /**
   * The name of the corresponding storage provider configuration.
   * @return storage
   */
  @javax.annotation.Nonnull
  public String getStorage() {
    return storage;
  }

  public void setStorage(@javax.annotation.Nonnull String storage) {
    this.storage = storage;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DtoBackupRoutine dtoBackupRoutine = (DtoBackupRoutine) o;
    return Objects.equals(this.backupPolicy, dtoBackupRoutine.backupPolicy) &&
        Objects.equals(this.binList, dtoBackupRoutine.binList) &&
        Objects.equals(this.disabled, dtoBackupRoutine.disabled) &&
        Objects.equals(this.incrIntervalCron, dtoBackupRoutine.incrIntervalCron) &&
        Objects.equals(this.intervalCron, dtoBackupRoutine.intervalCron) &&
        Objects.equals(this.namespaces, dtoBackupRoutine.namespaces) &&
        Objects.equals(this.nodeList, dtoBackupRoutine.nodeList) &&
        Objects.equals(this.partitionList, dtoBackupRoutine.partitionList) &&
        Objects.equals(this.preferRacks, dtoBackupRoutine.preferRacks) &&
        Objects.equals(this.secretAgent, dtoBackupRoutine.secretAgent) &&
        Objects.equals(this.setList, dtoBackupRoutine.setList) &&
        Objects.equals(this.sourceCluster, dtoBackupRoutine.sourceCluster) &&
        Objects.equals(this.storage, dtoBackupRoutine.storage);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(backupPolicy, binList, disabled, incrIntervalCron, intervalCron, namespaces, nodeList, partitionList, preferRacks, secretAgent, setList, sourceCluster, storage);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DtoBackupRoutine {\n");
    sb.append("    backupPolicy: ").append(toIndentedString(backupPolicy)).append("\n");
    sb.append("    binList: ").append(toIndentedString(binList)).append("\n");
    sb.append("    disabled: ").append(toIndentedString(disabled)).append("\n");
    sb.append("    incrIntervalCron: ").append(toIndentedString(incrIntervalCron)).append("\n");
    sb.append("    intervalCron: ").append(toIndentedString(intervalCron)).append("\n");
    sb.append("    namespaces: ").append(toIndentedString(namespaces)).append("\n");
    sb.append("    nodeList: ").append(toIndentedString(nodeList)).append("\n");
    sb.append("    partitionList: ").append(toIndentedString(partitionList)).append("\n");
    sb.append("    preferRacks: ").append(toIndentedString(preferRacks)).append("\n");
    sb.append("    secretAgent: ").append(toIndentedString(secretAgent)).append("\n");
    sb.append("    setList: ").append(toIndentedString(setList)).append("\n");
    sb.append("    sourceCluster: ").append(toIndentedString(sourceCluster)).append("\n");
    sb.append("    storage: ").append(toIndentedString(storage)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("backup-policy", "bin-list", "disabled", "incr-interval-cron", "interval-cron", "namespaces", "node-list", "partition-list", "prefer-racks", "secret-agent", "set-list", "source-cluster", "storage"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(Arrays.asList("interval-cron", "namespaces", "source-cluster", "storage"));
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DtoBackupRoutine
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DtoBackupRoutine.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DtoBackupRoutine is not found in the empty JSON string", DtoBackupRoutine.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DtoBackupRoutine.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DtoBackupRoutine` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : DtoBackupRoutine.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("backup-policy") != null && !jsonObj.get("backup-policy").isJsonNull()) && !jsonObj.get("backup-policy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `backup-policy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("backup-policy").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("bin-list") != null && !jsonObj.get("bin-list").isJsonNull() && !jsonObj.get("bin-list").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `bin-list` to be an array in the JSON string but got `%s`", jsonObj.get("bin-list").toString()));
      }
      if ((jsonObj.get("incr-interval-cron") != null && !jsonObj.get("incr-interval-cron").isJsonNull()) && !jsonObj.get("incr-interval-cron").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `incr-interval-cron` to be a primitive type in the JSON string but got `%s`", jsonObj.get("incr-interval-cron").toString()));
      }
      if (!jsonObj.get("interval-cron").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `interval-cron` to be a primitive type in the JSON string but got `%s`", jsonObj.get("interval-cron").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("namespaces") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("namespaces").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `namespaces` to be an array in the JSON string but got `%s`", jsonObj.get("namespaces").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("node-list") != null && !jsonObj.get("node-list").isJsonNull() && !jsonObj.get("node-list").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `node-list` to be an array in the JSON string but got `%s`", jsonObj.get("node-list").toString()));
      }
      if ((jsonObj.get("partition-list") != null && !jsonObj.get("partition-list").isJsonNull()) && !jsonObj.get("partition-list").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `partition-list` to be a primitive type in the JSON string but got `%s`", jsonObj.get("partition-list").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("prefer-racks") != null && !jsonObj.get("prefer-racks").isJsonNull() && !jsonObj.get("prefer-racks").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `prefer-racks` to be an array in the JSON string but got `%s`", jsonObj.get("prefer-racks").toString()));
      }
      if ((jsonObj.get("secret-agent") != null && !jsonObj.get("secret-agent").isJsonNull()) && !jsonObj.get("secret-agent").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secret-agent` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secret-agent").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("set-list") != null && !jsonObj.get("set-list").isJsonNull() && !jsonObj.get("set-list").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `set-list` to be an array in the JSON string but got `%s`", jsonObj.get("set-list").toString()));
      }
      if (!jsonObj.get("source-cluster").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `source-cluster` to be a primitive type in the JSON string but got `%s`", jsonObj.get("source-cluster").toString()));
      }
      if (!jsonObj.get("storage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storage").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DtoBackupRoutine.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DtoBackupRoutine' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DtoBackupRoutine> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DtoBackupRoutine.class));

       return (TypeAdapter<T>) new TypeAdapter<DtoBackupRoutine>() {
           @Override
           public void write(JsonWriter out, DtoBackupRoutine value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DtoBackupRoutine read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DtoBackupRoutine given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DtoBackupRoutine
   * @throws IOException if the JSON string is invalid with respect to DtoBackupRoutine
   */
  public static DtoBackupRoutine fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DtoBackupRoutine.class);
  }

  /**
   * Convert an instance of DtoBackupRoutine to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

