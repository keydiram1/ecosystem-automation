/*
 * Backup Service REST API Specification
 * Aerospike Backup Service
 *
 * The version of the OpenAPI document: v3.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package api.abs.generated.model;

import java.util.Objects;
import api.abs.generated.model.DtoCompressionPolicy;
import api.abs.generated.model.DtoEncryptionPolicy;
import api.abs.generated.model.DtoRestoreNamespace;
import api.abs.generated.model.DtoRetryPolicy;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import api.abs.generated.JSON;

/**
 * RestorePolicy represents a policy for the restore operation.
 */
public class DtoRestorePolicy {
  public static final String SERIALIZED_NAME_BANDWIDTH = "bandwidth";
  @SerializedName(SERIALIZED_NAME_BANDWIDTH)
  @javax.annotation.Nullable
  private Integer bandwidth;

  public static final String SERIALIZED_NAME_BATCH_SIZE = "batch-size";
  @SerializedName(SERIALIZED_NAME_BATCH_SIZE)
  @javax.annotation.Nullable
  private Integer batchSize = 128;

  public static final String SERIALIZED_NAME_BIN_LIST = "bin-list";
  @SerializedName(SERIALIZED_NAME_BIN_LIST)
  @javax.annotation.Nullable
  private List<String> binList;

  public static final String SERIALIZED_NAME_COMPRESSION = "compression";
  @SerializedName(SERIALIZED_NAME_COMPRESSION)
  @javax.annotation.Nullable
  private DtoCompressionPolicy compression;

  public static final String SERIALIZED_NAME_DISABLE_BATCH_WRITES = "disable-batch-writes";
  @SerializedName(SERIALIZED_NAME_DISABLE_BATCH_WRITES)
  @javax.annotation.Nullable
  private Boolean disableBatchWrites = false;

  public static final String SERIALIZED_NAME_ENCRYPTION = "encryption";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION)
  @javax.annotation.Nullable
  private DtoEncryptionPolicy encryption;

  public static final String SERIALIZED_NAME_EXTRA_TTL = "extra-ttl";
  @SerializedName(SERIALIZED_NAME_EXTRA_TTL)
  @javax.annotation.Nullable
  private Integer extraTtl = 0;

  public static final String SERIALIZED_NAME_MAX_ASYNC_BATCHES = "max-async-batches";
  @SerializedName(SERIALIZED_NAME_MAX_ASYNC_BATCHES)
  @javax.annotation.Nullable
  private Integer maxAsyncBatches = 128;

  public static final String SERIALIZED_NAME_NAMESPACE = "namespace";
  @SerializedName(SERIALIZED_NAME_NAMESPACE)
  @javax.annotation.Nullable
  private DtoRestoreNamespace namespace;

  public static final String SERIALIZED_NAME_NO_GENERATION = "no-generation";
  @SerializedName(SERIALIZED_NAME_NO_GENERATION)
  @javax.annotation.Nullable
  private Boolean noGeneration = false;

  public static final String SERIALIZED_NAME_NO_INDEXES = "no-indexes";
  @SerializedName(SERIALIZED_NAME_NO_INDEXES)
  @javax.annotation.Nullable
  private Boolean noIndexes = false;

  public static final String SERIALIZED_NAME_NO_RECORDS = "no-records";
  @SerializedName(SERIALIZED_NAME_NO_RECORDS)
  @javax.annotation.Nullable
  private Boolean noRecords = false;

  public static final String SERIALIZED_NAME_NO_UDFS = "no-udfs";
  @SerializedName(SERIALIZED_NAME_NO_UDFS)
  @javax.annotation.Nullable
  private Boolean noUdfs = false;

  public static final String SERIALIZED_NAME_PARALLEL = "parallel";
  @SerializedName(SERIALIZED_NAME_PARALLEL)
  @javax.annotation.Nullable
  private Integer parallel = 8;

  public static final String SERIALIZED_NAME_REPLACE = "replace";
  @SerializedName(SERIALIZED_NAME_REPLACE)
  @javax.annotation.Nullable
  private Boolean replace = false;

  public static final String SERIALIZED_NAME_RETRY_POLICY = "retry-policy";
  @SerializedName(SERIALIZED_NAME_RETRY_POLICY)
  @javax.annotation.Nullable
  private DtoRetryPolicy retryPolicy;

  public static final String SERIALIZED_NAME_SET_LIST = "set-list";
  @SerializedName(SERIALIZED_NAME_SET_LIST)
  @javax.annotation.Nullable
  private List<String> setList;

  public static final String SERIALIZED_NAME_SOCKET_TIMEOUT = "socket-timeout";
  @SerializedName(SERIALIZED_NAME_SOCKET_TIMEOUT)
  @javax.annotation.Nullable
  private Integer socketTimeout = 60000;

  public static final String SERIALIZED_NAME_TOTAL_TIMEOUT = "total-timeout";
  @SerializedName(SERIALIZED_NAME_TOTAL_TIMEOUT)
  @javax.annotation.Nullable
  private Integer totalTimeout = 0;

  public static final String SERIALIZED_NAME_TPS = "tps";
  @SerializedName(SERIALIZED_NAME_TPS)
  @javax.annotation.Nullable
  private Integer tps;

  public static final String SERIALIZED_NAME_UNIQUE = "unique";
  @SerializedName(SERIALIZED_NAME_UNIQUE)
  @javax.annotation.Nullable
  private Boolean unique = false;

  public DtoRestorePolicy() {
  }

  public DtoRestorePolicy bandwidth(@javax.annotation.Nullable Integer bandwidth) {
    this.bandwidth = bandwidth;
    return this;
  }

  /**
   * Throttles read operations from the backup file(s) to not exceed the given I/O bandwidth in MiB/s. Default: no limit.
   * @return bandwidth
   */
  @javax.annotation.Nullable
  public Integer getBandwidth() {
    return bandwidth;
  }

  public void setBandwidth(@javax.annotation.Nullable Integer bandwidth) {
    this.bandwidth = bandwidth;
  }


  public DtoRestorePolicy batchSize(@javax.annotation.Nullable Integer batchSize) {
    this.batchSize = batchSize;
    return this;
  }

  /**
   * The max allowed number of records per an async batch write call. Only applicable when using batch writes.
   * @return batchSize
   */
  @javax.annotation.Nullable
  public Integer getBatchSize() {
    return batchSize;
  }

  public void setBatchSize(@javax.annotation.Nullable Integer batchSize) {
    this.batchSize = batchSize;
  }


  public DtoRestorePolicy binList(@javax.annotation.Nullable List<String> binList) {
    this.binList = binList;
    return this;
  }

  public DtoRestorePolicy addBinListItem(String binListItem) {
    if (this.binList == null) {
      this.binList = new ArrayList<>();
    }
    this.binList.add(binListItem);
    return this;
  }

  /**
   * The bins to restore (optional, an empty list implies restoring all bins).
   * @return binList
   */
  @javax.annotation.Nullable
  public List<String> getBinList() {
    return binList;
  }

  public void setBinList(@javax.annotation.Nullable List<String> binList) {
    this.binList = binList;
  }


  public DtoRestorePolicy compression(@javax.annotation.Nullable DtoCompressionPolicy compression) {
    this.compression = compression;
    return this;
  }

  /**
   * Compression details (algorithm). Default is no compression.
   * @return compression
   */
  @javax.annotation.Nullable
  public DtoCompressionPolicy getCompression() {
    return compression;
  }

  public void setCompression(@javax.annotation.Nullable DtoCompressionPolicy compression) {
    this.compression = compression;
  }


  public DtoRestorePolicy disableBatchWrites(@javax.annotation.Nullable Boolean disableBatchWrites) {
    this.disableBatchWrites = disableBatchWrites;
    return this;
  }

  /**
   * Disables the use of batch writes when restoring records to the Aerospike cluster. By default, the cluster is checked for batch write support.
   * @return disableBatchWrites
   */
  @javax.annotation.Nullable
  public Boolean getDisableBatchWrites() {
    return disableBatchWrites;
  }

  public void setDisableBatchWrites(@javax.annotation.Nullable Boolean disableBatchWrites) {
    this.disableBatchWrites = disableBatchWrites;
  }


  public DtoRestorePolicy encryption(@javax.annotation.Nullable DtoEncryptionPolicy encryption) {
    this.encryption = encryption;
    return this;
  }

  /**
   * Encryption details (algorithm and key). Default is no encryption.
   * @return encryption
   */
  @javax.annotation.Nullable
  public DtoEncryptionPolicy getEncryption() {
    return encryption;
  }

  public void setEncryption(@javax.annotation.Nullable DtoEncryptionPolicy encryption) {
    this.encryption = encryption;
  }


  public DtoRestorePolicy extraTtl(@javax.annotation.Nullable Integer extraTtl) {
    this.extraTtl = extraTtl;
    return this;
  }

  /**
   * Amount of extra time-to-live to add to records that have expirable void-times. Must be set in seconds.
   * @return extraTtl
   */
  @javax.annotation.Nullable
  public Integer getExtraTtl() {
    return extraTtl;
  }

  public void setExtraTtl(@javax.annotation.Nullable Integer extraTtl) {
    this.extraTtl = extraTtl;
  }


  public DtoRestorePolicy maxAsyncBatches(@javax.annotation.Nullable Integer maxAsyncBatches) {
    this.maxAsyncBatches = maxAsyncBatches;
    return this;
  }

  /**
   * The max number of outstanding async record batch write calls at a time.
   * @return maxAsyncBatches
   */
  @javax.annotation.Nullable
  public Integer getMaxAsyncBatches() {
    return maxAsyncBatches;
  }

  public void setMaxAsyncBatches(@javax.annotation.Nullable Integer maxAsyncBatches) {
    this.maxAsyncBatches = maxAsyncBatches;
  }


  public DtoRestorePolicy namespace(@javax.annotation.Nullable DtoRestoreNamespace namespace) {
    this.namespace = namespace;
    return this;
  }

  /**
   * Namespace optionally specifies an alternative namespace name for the restore operation. By default, the data is restored to the namespace from which it was taken.
   * @return namespace
   */
  @javax.annotation.Nullable
  public DtoRestoreNamespace getNamespace() {
    return namespace;
  }

  public void setNamespace(@javax.annotation.Nullable DtoRestoreNamespace namespace) {
    this.namespace = namespace;
  }


  public DtoRestorePolicy noGeneration(@javax.annotation.Nullable Boolean noGeneration) {
    this.noGeneration = noGeneration;
    return this;
  }

  /**
   * Records from backups take precedence. This option disables the generation check. With this option, records from the backup always overwrite records that already exist in the namespace, regardless of generation numbers.
   * @return noGeneration
   */
  @javax.annotation.Nullable
  public Boolean getNoGeneration() {
    return noGeneration;
  }

  public void setNoGeneration(@javax.annotation.Nullable Boolean noGeneration) {
    this.noGeneration = noGeneration;
  }


  public DtoRestorePolicy noIndexes(@javax.annotation.Nullable Boolean noIndexes) {
    this.noIndexes = noIndexes;
    return this;
  }

  /**
   * Do not restore any secondary index definitions.
   * @return noIndexes
   */
  @javax.annotation.Nullable
  public Boolean getNoIndexes() {
    return noIndexes;
  }

  public void setNoIndexes(@javax.annotation.Nullable Boolean noIndexes) {
    this.noIndexes = noIndexes;
  }


  public DtoRestorePolicy noRecords(@javax.annotation.Nullable Boolean noRecords) {
    this.noRecords = noRecords;
    return this;
  }

  /**
   * Do not restore any record data (metadata or bin data). By default, record data, secondary index definitions, and UDF modules will be restored.
   * @return noRecords
   */
  @javax.annotation.Nullable
  public Boolean getNoRecords() {
    return noRecords;
  }

  public void setNoRecords(@javax.annotation.Nullable Boolean noRecords) {
    this.noRecords = noRecords;
  }


  public DtoRestorePolicy noUdfs(@javax.annotation.Nullable Boolean noUdfs) {
    this.noUdfs = noUdfs;
    return this;
  }

  /**
   * Do not restore any UDF modules.
   * @return noUdfs
   */
  @javax.annotation.Nullable
  public Boolean getNoUdfs() {
    return noUdfs;
  }

  public void setNoUdfs(@javax.annotation.Nullable Boolean noUdfs) {
    this.noUdfs = noUdfs;
  }


  public DtoRestorePolicy parallel(@javax.annotation.Nullable Integer parallel) {
    this.parallel = parallel;
    return this;
  }

  /**
   * The number of concurrent record readers from backup files. This value controls the level of parallelism used by the backup service when reading backup files. The optimal value depends on hardware and network configuration.
   * @return parallel
   */
  @javax.annotation.Nullable
  public Integer getParallel() {
    return parallel;
  }

  public void setParallel(@javax.annotation.Nullable Integer parallel) {
    this.parallel = parallel;
  }


  public DtoRestorePolicy replace(@javax.annotation.Nullable Boolean replace) {
    this.replace = replace;
    return this;
  }

  /**
   * Replace records. This controls how records from the backup overwrite existing records in the namespace. By default, restoring a record from a backup only replaces the bins contained in the backup; all other bins of an existing record remain untouched.
   * @return replace
   */
  @javax.annotation.Nullable
  public Boolean getReplace() {
    return replace;
  }

  public void setReplace(@javax.annotation.Nullable Boolean replace) {
    this.replace = replace;
  }


  public DtoRestorePolicy retryPolicy(@javax.annotation.Nullable DtoRetryPolicy retryPolicy) {
    this.retryPolicy = retryPolicy;
    return this;
  }

  /**
   * Configuration of retries for each restore write operation. If nil, the default policy is used (5 retries with a one-minute delay between attempts).
   * @return retryPolicy
   */
  @javax.annotation.Nullable
  public DtoRetryPolicy getRetryPolicy() {
    return retryPolicy;
  }

  public void setRetryPolicy(@javax.annotation.Nullable DtoRetryPolicy retryPolicy) {
    this.retryPolicy = retryPolicy;
  }


  public DtoRestorePolicy setList(@javax.annotation.Nullable List<String> setList) {
    this.setList = setList;
    return this;
  }

  public DtoRestorePolicy addSetListItem(String setListItem) {
    if (this.setList == null) {
      this.setList = new ArrayList<>();
    }
    this.setList.add(setListItem);
    return this;
  }

  /**
   * The sets to restore (optional, an empty list implies restoring all sets).
   * @return setList
   */
  @javax.annotation.Nullable
  public List<String> getSetList() {
    return setList;
  }

  public void setSetList(@javax.annotation.Nullable List<String> setList) {
    this.setList = setList;
  }


  public DtoRestorePolicy socketTimeout(@javax.annotation.Nullable Integer socketTimeout) {
    this.socketTimeout = socketTimeout;
    return this;
  }

  /**
   * Timeout (ms) for Aerospike commands to write records, create indexes and create UDFs. Socket timeout in milliseconds. Default is 10 minutes. If this value is 0, it is set to total-timeout. If both are 0, there is no socket idle time limit.
   * @return socketTimeout
   */
  @javax.annotation.Nullable
  public Integer getSocketTimeout() {
    return socketTimeout;
  }

  public void setSocketTimeout(@javax.annotation.Nullable Integer socketTimeout) {
    this.socketTimeout = socketTimeout;
  }


  public DtoRestorePolicy totalTimeout(@javax.annotation.Nullable Integer totalTimeout) {
    this.totalTimeout = totalTimeout;
    return this;
  }

  /**
   * Total socket timeout in milliseconds. Default is 0, that is, no timeout.
   * @return totalTimeout
   */
  @javax.annotation.Nullable
  public Integer getTotalTimeout() {
    return totalTimeout;
  }

  public void setTotalTimeout(@javax.annotation.Nullable Integer totalTimeout) {
    this.totalTimeout = totalTimeout;
  }


  public DtoRestorePolicy tps(@javax.annotation.Nullable Integer tps) {
    this.tps = tps;
    return this;
  }

  /**
   * Throttles read operations from the backup file(s) to not exceed the given number of transactions per second. Default: no limit.
   * @return tps
   */
  @javax.annotation.Nullable
  public Integer getTps() {
    return tps;
  }

  public void setTps(@javax.annotation.Nullable Integer tps) {
    this.tps = tps;
  }


  public DtoRestorePolicy unique(@javax.annotation.Nullable Boolean unique) {
    this.unique = unique;
    return this;
  }

  /**
   * Existing records take precedence. With this option, only records that do not exist in the namespace are restored, regardless of generation numbers. If a record exists in the namespace, the record from the backup is ignored.
   * @return unique
   */
  @javax.annotation.Nullable
  public Boolean getUnique() {
    return unique;
  }

  public void setUnique(@javax.annotation.Nullable Boolean unique) {
    this.unique = unique;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DtoRestorePolicy dtoRestorePolicy = (DtoRestorePolicy) o;
    return Objects.equals(this.bandwidth, dtoRestorePolicy.bandwidth) &&
        Objects.equals(this.batchSize, dtoRestorePolicy.batchSize) &&
        Objects.equals(this.binList, dtoRestorePolicy.binList) &&
        Objects.equals(this.compression, dtoRestorePolicy.compression) &&
        Objects.equals(this.disableBatchWrites, dtoRestorePolicy.disableBatchWrites) &&
        Objects.equals(this.encryption, dtoRestorePolicy.encryption) &&
        Objects.equals(this.extraTtl, dtoRestorePolicy.extraTtl) &&
        Objects.equals(this.maxAsyncBatches, dtoRestorePolicy.maxAsyncBatches) &&
        Objects.equals(this.namespace, dtoRestorePolicy.namespace) &&
        Objects.equals(this.noGeneration, dtoRestorePolicy.noGeneration) &&
        Objects.equals(this.noIndexes, dtoRestorePolicy.noIndexes) &&
        Objects.equals(this.noRecords, dtoRestorePolicy.noRecords) &&
        Objects.equals(this.noUdfs, dtoRestorePolicy.noUdfs) &&
        Objects.equals(this.parallel, dtoRestorePolicy.parallel) &&
        Objects.equals(this.replace, dtoRestorePolicy.replace) &&
        Objects.equals(this.retryPolicy, dtoRestorePolicy.retryPolicy) &&
        Objects.equals(this.setList, dtoRestorePolicy.setList) &&
        Objects.equals(this.socketTimeout, dtoRestorePolicy.socketTimeout) &&
        Objects.equals(this.totalTimeout, dtoRestorePolicy.totalTimeout) &&
        Objects.equals(this.tps, dtoRestorePolicy.tps) &&
        Objects.equals(this.unique, dtoRestorePolicy.unique);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(bandwidth, batchSize, binList, compression, disableBatchWrites, encryption, extraTtl, maxAsyncBatches, namespace, noGeneration, noIndexes, noRecords, noUdfs, parallel, replace, retryPolicy, setList, socketTimeout, totalTimeout, tps, unique);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DtoRestorePolicy {\n");
    sb.append("    bandwidth: ").append(toIndentedString(bandwidth)).append("\n");
    sb.append("    batchSize: ").append(toIndentedString(batchSize)).append("\n");
    sb.append("    binList: ").append(toIndentedString(binList)).append("\n");
    sb.append("    compression: ").append(toIndentedString(compression)).append("\n");
    sb.append("    disableBatchWrites: ").append(toIndentedString(disableBatchWrites)).append("\n");
    sb.append("    encryption: ").append(toIndentedString(encryption)).append("\n");
    sb.append("    extraTtl: ").append(toIndentedString(extraTtl)).append("\n");
    sb.append("    maxAsyncBatches: ").append(toIndentedString(maxAsyncBatches)).append("\n");
    sb.append("    namespace: ").append(toIndentedString(namespace)).append("\n");
    sb.append("    noGeneration: ").append(toIndentedString(noGeneration)).append("\n");
    sb.append("    noIndexes: ").append(toIndentedString(noIndexes)).append("\n");
    sb.append("    noRecords: ").append(toIndentedString(noRecords)).append("\n");
    sb.append("    noUdfs: ").append(toIndentedString(noUdfs)).append("\n");
    sb.append("    parallel: ").append(toIndentedString(parallel)).append("\n");
    sb.append("    replace: ").append(toIndentedString(replace)).append("\n");
    sb.append("    retryPolicy: ").append(toIndentedString(retryPolicy)).append("\n");
    sb.append("    setList: ").append(toIndentedString(setList)).append("\n");
    sb.append("    socketTimeout: ").append(toIndentedString(socketTimeout)).append("\n");
    sb.append("    totalTimeout: ").append(toIndentedString(totalTimeout)).append("\n");
    sb.append("    tps: ").append(toIndentedString(tps)).append("\n");
    sb.append("    unique: ").append(toIndentedString(unique)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("bandwidth", "batch-size", "bin-list", "compression", "disable-batch-writes", "encryption", "extra-ttl", "max-async-batches", "namespace", "no-generation", "no-indexes", "no-records", "no-udfs", "parallel", "replace", "retry-policy", "set-list", "socket-timeout", "total-timeout", "tps", "unique"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(0);
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DtoRestorePolicy
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DtoRestorePolicy.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DtoRestorePolicy is not found in the empty JSON string", DtoRestorePolicy.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DtoRestorePolicy.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DtoRestorePolicy` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("bin-list") != null && !jsonObj.get("bin-list").isJsonNull() && !jsonObj.get("bin-list").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `bin-list` to be an array in the JSON string but got `%s`", jsonObj.get("bin-list").toString()));
      }
      // validate the optional field `compression`
      if (jsonObj.get("compression") != null && !jsonObj.get("compression").isJsonNull()) {
        DtoCompressionPolicy.validateJsonElement(jsonObj.get("compression"));
      }
      // validate the optional field `encryption`
      if (jsonObj.get("encryption") != null && !jsonObj.get("encryption").isJsonNull()) {
        DtoEncryptionPolicy.validateJsonElement(jsonObj.get("encryption"));
      }
      // validate the optional field `namespace`
      if (jsonObj.get("namespace") != null && !jsonObj.get("namespace").isJsonNull()) {
        DtoRestoreNamespace.validateJsonElement(jsonObj.get("namespace"));
      }
      // validate the optional field `retry-policy`
      if (jsonObj.get("retry-policy") != null && !jsonObj.get("retry-policy").isJsonNull()) {
        DtoRetryPolicy.validateJsonElement(jsonObj.get("retry-policy"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("set-list") != null && !jsonObj.get("set-list").isJsonNull() && !jsonObj.get("set-list").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `set-list` to be an array in the JSON string but got `%s`", jsonObj.get("set-list").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DtoRestorePolicy.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DtoRestorePolicy' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DtoRestorePolicy> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DtoRestorePolicy.class));

       return (TypeAdapter<T>) new TypeAdapter<DtoRestorePolicy>() {
           @Override
           public void write(JsonWriter out, DtoRestorePolicy value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DtoRestorePolicy read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DtoRestorePolicy given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DtoRestorePolicy
   * @throws IOException if the JSON string is invalid with respect to DtoRestorePolicy
   */
  public static DtoRestorePolicy fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DtoRestorePolicy.class);
  }

  /**
   * Convert an instance of DtoRestorePolicy to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

