/*
 * Backup Service REST API Specification
 * Aerospike Backup Service
 *
 * The version of the OpenAPI document: v3.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package api.abs.generated.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import api.abs.generated.JSON;

/**
 * FileLoggerConfig represents the configuration for the file logger writer.
 */
public class DtoFileLoggerConfig {
  public static final String SERIALIZED_NAME_COMPRESS = "compress";
  @SerializedName(SERIALIZED_NAME_COMPRESS)
  @javax.annotation.Nullable
  private Boolean compress = false;

  public static final String SERIALIZED_NAME_FILENAME = "filename";
  @SerializedName(SERIALIZED_NAME_FILENAME)
  @javax.annotation.Nonnull
  private String filename;

  public static final String SERIALIZED_NAME_MAXAGE = "maxage";
  @SerializedName(SERIALIZED_NAME_MAXAGE)
  @javax.annotation.Nullable
  private Integer maxage;

  public static final String SERIALIZED_NAME_MAXBACKUPS = "maxbackups";
  @SerializedName(SERIALIZED_NAME_MAXBACKUPS)
  @javax.annotation.Nullable
  private Integer maxbackups;

  public static final String SERIALIZED_NAME_MAXSIZE = "maxsize";
  @SerializedName(SERIALIZED_NAME_MAXSIZE)
  @javax.annotation.Nullable
  private Integer maxsize;

  public DtoFileLoggerConfig() {
  }

  public DtoFileLoggerConfig compress(@javax.annotation.Nullable Boolean compress) {
    this.compress = compress;
    return this;
  }

  /**
   * Compress determines if the rotated log files should be compressed using gzip. The default is not to perform compression.
   * @return compress
   */
  @javax.annotation.Nullable
  public Boolean getCompress() {
    return compress;
  }

  public void setCompress(@javax.annotation.Nullable Boolean compress) {
    this.compress = compress;
  }


  public DtoFileLoggerConfig filename(@javax.annotation.Nonnull String filename) {
    this.filename = filename;
    return this;
  }

  /**
   * Filename is the file to write logs to.
   * @return filename
   */
  @javax.annotation.Nonnull
  public String getFilename() {
    return filename;
  }

  public void setFilename(@javax.annotation.Nonnull String filename) {
    this.filename = filename;
  }


  public DtoFileLoggerConfig maxage(@javax.annotation.Nullable Integer maxage) {
    this.maxage = maxage;
    return this;
  }

  /**
   * MaxAge is the maximum number of days to retain old log files based on the timestamp encoded in their filename. The default is not to remove old log files based on age.
   * @return maxage
   */
  @javax.annotation.Nullable
  public Integer getMaxage() {
    return maxage;
  }

  public void setMaxage(@javax.annotation.Nullable Integer maxage) {
    this.maxage = maxage;
  }


  public DtoFileLoggerConfig maxbackups(@javax.annotation.Nullable Integer maxbackups) {
    this.maxbackups = maxbackups;
    return this;
  }

  /**
   * MaxBackups is the maximum number of old log files to retain. The default is to retain all old log files.
   * @return maxbackups
   */
  @javax.annotation.Nullable
  public Integer getMaxbackups() {
    return maxbackups;
  }

  public void setMaxbackups(@javax.annotation.Nullable Integer maxbackups) {
    this.maxbackups = maxbackups;
  }


  public DtoFileLoggerConfig maxsize(@javax.annotation.Nullable Integer maxsize) {
    this.maxsize = maxsize;
    return this;
  }

  /**
   * MaxSize is the maximum size in megabytes of the log file before it gets rotated.
   * @return maxsize
   */
  @javax.annotation.Nullable
  public Integer getMaxsize() {
    return maxsize;
  }

  public void setMaxsize(@javax.annotation.Nullable Integer maxsize) {
    this.maxsize = maxsize;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DtoFileLoggerConfig dtoFileLoggerConfig = (DtoFileLoggerConfig) o;
    return Objects.equals(this.compress, dtoFileLoggerConfig.compress) &&
        Objects.equals(this.filename, dtoFileLoggerConfig.filename) &&
        Objects.equals(this.maxage, dtoFileLoggerConfig.maxage) &&
        Objects.equals(this.maxbackups, dtoFileLoggerConfig.maxbackups) &&
        Objects.equals(this.maxsize, dtoFileLoggerConfig.maxsize);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(compress, filename, maxage, maxbackups, maxsize);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DtoFileLoggerConfig {\n");
    sb.append("    compress: ").append(toIndentedString(compress)).append("\n");
    sb.append("    filename: ").append(toIndentedString(filename)).append("\n");
    sb.append("    maxage: ").append(toIndentedString(maxage)).append("\n");
    sb.append("    maxbackups: ").append(toIndentedString(maxbackups)).append("\n");
    sb.append("    maxsize: ").append(toIndentedString(maxsize)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("compress", "filename", "maxage", "maxbackups", "maxsize"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(Arrays.asList("filename"));
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DtoFileLoggerConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DtoFileLoggerConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DtoFileLoggerConfig is not found in the empty JSON string", DtoFileLoggerConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DtoFileLoggerConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DtoFileLoggerConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : DtoFileLoggerConfig.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("filename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filename").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DtoFileLoggerConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DtoFileLoggerConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DtoFileLoggerConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DtoFileLoggerConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<DtoFileLoggerConfig>() {
           @Override
           public void write(JsonWriter out, DtoFileLoggerConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DtoFileLoggerConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DtoFileLoggerConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DtoFileLoggerConfig
   * @throws IOException if the JSON string is invalid with respect to DtoFileLoggerConfig
   */
  public static DtoFileLoggerConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DtoFileLoggerConfig.class);
  }

  /**
   * Convert an instance of DtoFileLoggerConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

